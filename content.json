{"meta":{"title":"Ryhen'blog |Code|Life|Love","subtitle":"","description":"","author":"Ryhen Kao","url":"http://ryhenkao.github.io","root":"/"},"posts":[{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"AES","date":"2020/01/01","text":"AES概况NIST公开征集 1998~2000年经历三轮审查 2001年最终选定一个算法并制定其位标准设计要求 安全性：可抵御目前已知攻击 实用性：适应各种应用环境 扩展性：分组长度和密钥长度可扩展 特点 分组密码：现在使用明文密文长度为128位，密钥长度可变（128/256等等） 面向二进制： 能够加解密任何计算机数据 不是对合运算： 加解密使用不同的算法（但是结构基本一样） 综合运用多种密码古典密码技术： 置换、代替、异或 整体结构：采用SP结构（S盒+P置换），基本轮函数循环迭代 AES的子表示与运算 AES的数据处理单位是字节和字 一个字=4个字节=（4×8bit）32bit 一个字可以表示为系数取自GF(2^8)上的次数低于4次的多项式状态 加解密状态的中间数据 以字节为元素的矩阵或是二维数组 Nb——明文所含的字数 Nk——密钥所含的字数 Nr——迭代轮数 轮函数共进行10轮变换 前9轮成为标准轮函数 最后一轮非标准轮函数 标准轮函数S盒变换+P置换（行移位变换+列混合变换）+轮密钥加 非标准轮函数S盒变换+行移位变换+轮密钥加 S盒变换AES的唯一非线性变换 AES的S盒输入输出都是8位，是非线性置换 AES使用16个相同的S盒（一个S盒对应一个状态，一个状态对应一个字节） S盒操作 将输入字节用其GF(2^8)上的逆元素表示（非线性变换） 把输入的字节看成GF(2^8)上的元素 求出其在域上的逆元素 用逆元素代替原输入字节 对第一步的结果做仿射变换（线性变换） 行移位 对状态的行进行循环移位 第0行不移位，第1行移C1自己，第二行移C2字节，第三行移C3字节 C1~3的取值由下表规定 Nb C1 C2 C3 4 1 2 3 6 1 2 3 行移位变换属于置换，是线性变换，本质在于把数据打乱重排，起扩散作用 列混合 列混合变换把状态看作GF(2^8)上的 一个多项式a(x)，乘以一个固定的多项式c(x)，并模x^4+1 c(x) = 03x^3 + 01x^2 + 01x + 02 列混合变换属于线性变换，起扩散作用 c(x)与x^4+1互素，保证了c(x)存在逆多项式d(x)，只有存在d(x)才能进行解密 轮密钥加 轮密钥与状态进行模2相加 轮密钥根据密钥产生算法生成 轮密钥长度等于数据块长度 轮密钥生成 密钥扩展 轮密钥选择 密钥扩展轮密钥选择 根据分组的大小，一次从扩展密钥中去除轮密钥 前Nb个字作为轮密钥0，接下来Nb个字作为轮密钥1，…… AES的解密AES的加密算法不是对合运算；但是AES的解密算法和加密算法的结构相同把加密算法的每一个变换变成其逆运算即可 AES的基本逆变换 轮密钥加 轮密钥加变化的逆就是其本身 行移位变换 行移位变换的逆是状态的后三行分别移动（Nb-Ci）位，i=1，2，3 列混合变换 把状态的每一列乘以一个固定多项式d(x),d(x)=c(x)^-1 S盒 第一步：进行逆仿射变换 第二步：把每个字节用其在GF(2^8)中的逆来代替 解密的密钥扩展 第一步：使用与加密算法相同的密钥扩展 第二步：把InvMixColumn（逆列混合变换）用到除去第一和最后一轮意外的所有轮密钥上 AES的实现基于算法的软件实现 基于查表的软件实现 S盒查表 列混合查表 轮函数查表AES的安全性能抵御目前所有的已知攻击 穷举攻击、差分攻击、线性攻击、 Square攻击、侧信道攻击目前存在低于穷举复杂度的攻击方式，但是还不能对AES造成本质威胁","permalink":"http://ryhenkao.github.io/2020/01/01/AES/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"公钥密码","date":"2019/12/28","text":"公钥密码的基本思想传统密码的优缺点 优点1理论和实践都很成熟2安全容易把握3加解密速度快 缺点1收发双方持有相同密钥，Ke&#x3D;Kd，密钥分发困难，在网络环境更突出2不能方便地实现数字签名，商业等应用也不方便 公开密钥密码的基本思想 将密钥K一分为二：Ke和Kd。Ke专门加密，Kd专门解密，且Ke与Kd不相等 由Ke不能计算出Kd，于是可以将Ke公开，使密钥Ke分配简单 由于Ke与Kd不相等且由Ke不能计算出Kd，所以Kd可以作为用户的指纹，方便地实现数字签名 公开密钥密码的基本条件 E()和D()分别是加密和解密算法 保密条件： D和E互逆，即D(E(M))=M 安全条件：Ke与Kd不相等且由Ke不能计算出Kd 实用条件：E和D都高效 保真条件：E(D(M))=M 满足条件1、2、3可以用于保密；满足条件2、3、4可以用于保真（数字签名）；四个条件同时满足即可用于保密和保真 公钥密码的理论模型 1.单向函数：y=f(x)需要满足以下两个函数 1· 如果对于给定的x，计算y&#x3D;f(x)很容易2· 对于给定的y，要计算出x&#x3D;f^-1(y)很难 2.利用单向函数构造密码 1· 用正变换做加密，加密效率高2· 用逆变换做解密，安全，攻击者不可破译3· 但是合法的收信者也无法解密 3.单向陷门函数 设函数y=f(x)且f具有陷门，满足以下两个条件称f(x)的单向陷门函数 1· 如果对于给定的x，计算出y&#x3D;f(x)很容易2· 对于给定的y，如果不掌握陷门要计算出x很困难；如果掌握了陷门要计算出x很容易 4.利用单向陷门函数构造密码 1· 用正变换做加密，加密效率高2· 用逆变换做解密，安全3· 把陷门作为密钥，且只分配给合法用户。确保合法用户能够方便解密，而非法用户不能破译 5.单向函数的研究现状 理论上，不能证明单向函数一定存在 实际上， 密码学认为之哟啊函数的单向性足够应用就行 已知单向性足够的函数： 1· 大合数的因式分解问题2· 有限域上的离散对数问题3· 椭圆曲线离散对数问题 公钥密码的基本工作方式· 设M为明文，C为密文，E为加密算法，D为解密算法 · 每个用户都配置一对密钥Ke（公开的加密密钥）和Kd（保密的解密密钥） · 将所有哦用户的公开加密密钥Ke存入共享的密钥数据库PKDB · 保密的解密密钥Kd由用户妥善保管 1.确保数据的秘密性： 1发送方：2 1.A查找PKDB（公钥数据库），找到B的公开密钥KeB3 2.A用KeB加密密文M得到密文C：C&#x3D;E(M,KeB)4 3.A将C发送给B5接收方：6 1.B接收C7 2.B用自己的KdB解密，得到明文M&#x3D;D(C,KdB) 安全性分析：保证了数据的秘密性，但是不确保数据的真实性，保密但是不保真 2.确保数据的真实性： 1发送方：2 1.A用自己的KdA对M进行解密，得到C&#x3D;D(M,KdA)3 2.A将C发送给B4接收方：5 1.B接收C6 2.B通过PKDB查询A的公开加密密钥KeA7 3.B使用KeA加密C，得到明文M&#x3D;(C,KeA) 安全性分析：保证了真实性，但是不确保数据的秘密性，保真但是不保密 3.确保秘密性与真实性 1发送方：2 1.A首先用KdA对M解密，得到中间密文S3 2.A查PKDB，得到B的KeB4 3.用Keb对S进行加密得到C5接收方：6 1.B接收C7 2.B用自己的KdB解密C得到中间密文S8 3.B查PKDB，得到A的KeA9 4.用KeA对密文S进行加密得到明文M 安全性分析：保证了真实性与秘密性 ElGamal建立在离散对数问题的基础上· 随机选择一个大素数p，要求（p-1）具有大素数因子。选择一个模p的本原根a，并且公开a和p作为密码的基础参数 · 用户随机生成一个正整数d，2≤d≤p-2，作为私钥 · 用户计算 y=a^d mod p 得出公钥y 加密将明文M（0≤M≤p-1）加密成密文的过程如下： · 随机的选取一个整数k，2≤k≤p-2 · 计算 1U &#x3D; y^k mod p &#x2F;&#x2F;y是公钥2C1 &#x3D; a^k mod p3C2 &#x3D; UM mod p · 取C=（C1，C2）作为密文 解密将密文（C1,C2）解密过程如下： 1V &#x3D; C1^d mod p2M &#x3D; C2*(V^-1) mod p 得到明文M 安全性· 安全性建立在GF(p)离散对数的困难性之上 · 为了安全考量，p应该在150位以上的十进制数，且(p-1)应该有大素数因子 · d和k都不能太小 · 安全加密和签名所使用的k都必须是一次性的 Diffie-Hellman密钥交换· 目的是使两个用户可以安全地交换密钥，以便在后续的通信中使用该密钥进行消息加密 · 算法有效性建立在离散对数问题求解的困难性上 · 对素数p的本原根a求幂，实现范围从1到p-1的一个置换 D-H密钥交换算法· 存在两个公开的整数：素数q和本原根a · 用户A随机选择一个整数 XA&lt;q 并计算 YA=a^(XA) mod q · 用户B也独立选择一个随机整数 XB&lt;q 并计算 YB=a^(XB) mod q · A和B保持各自的X是私有的，但是对另一方公开Y · 用户A计算 K=(YB)^(XA) mod q，并将其作为密钥 · 用户B计算 K=(YA)^(XB) mod q，并将其作为密钥 最终两个K的计算结果是相同的，也就完成了密钥的确定过程。 1KA &#x3D;(YB)^(XA)mod q2 &#x3D;(a^(XB)mod q)^(XA)mod q3 &#x3D;(a^(XB))^(XA)mod q4KB &#x3D;(YA)^(XB)mod q5 &#x3D;(a^(XA)mod q)^(XB)mod q6 &#x3D;(a^(XA))^(XB)mod q7 &#x3D;(a^(XB))^(XA)mod q &#x3D; KA 椭圆曲线椭圆曲线的定义椭圆曲线的算数1E : Y^2&#x3D; X^3 + AX + B23be an elliptic curve and let P1 and P2 be points on E.45(a) If P1 &#x3D; O, then P1 + P2 &#x3D; P2.67(b) Otherwise, if P2 &#x3D; O, then P1 + P2 &#x3D; P1.89(c) Otherwise, write P1 &#x3D; (x1, y1) and P2 &#x3D; (x2, y2).1011(d) If x1 &#x3D; x2 and y1 &#x3D; −y2, then P1 + P2 &#x3D; O.1213(e) Otherwise, define λ by14 15 if P1&#x3D;P2, then λ&#x3D;(y2-y1)&#x2F;(x2-x1)16 if P1≠P2, then λ&#x3D;(3*x1^2+A)&#x2F;(2*y1)1718then let1920x3 &#x3D; λ^2 − x1 − x2 and y3 &#x3D; λ(x1 − x3) − y1.2122Then P1 + P2 &#x3D; (x3, y3). 椭圆曲线困难问题####椭圆曲线离散对数问题ECDLP给出椭圆曲线上的两点P和Q，求解以P为底Q的对数k ECDLP求解大步小步法 椭圆曲线的安全性椭圆曲线密码的困难性建立在椭圆曲线对数求解问题之上。Pollar rho方法是目前已知最快的椭圆曲线对数求解方法。已知的是，ECC使用的密钥长度比RSA中使用的密钥长度短得多。而且在密钥长度相同时，ECC与RSA执行所需的计算量相差不多。因此，在具有相同安全性的情况下，ECC使用的密钥比RSA更短，计算量也比RSA更少。","permalink":"http://ryhenkao.github.io/2019/12/28/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"数据加密标准 DES","date":"2019/12/19","text":"概念对称加密：加密密钥=解密密钥 序列（流）密码：对明文数据进行逐位（每一比特或是每一字节）进行异或 分组密码： 将明文数据分成等长的若干组再进行处理 分组密码输出块中的每一位都是由（输入块+钥匙）的每一位决定的 方式：代替、置换、异或 产生效果： 1混淆：代替、异或2扩散：移位 特点：良好的扩散性和对插入的敏感性 代替与换位代替（S盒） 1混淆：不同输入导致相同的输出2扩散：输入数据中1bit的变换造成多个bit的输出变换3操作：算术&#x2F;逻辑运算，非线性映射4受计算机字长和计算能力的限制，代替处理的数据宽度有限。需要多个代替模块 换位（置换）permutation 1交换各个数据位的位置 代替+换位=更大规模的混淆与扩散效果 Feistel结构一次加密 1(密钥+临时数据)代替与换位&#x3D;密钥流2(明文+密钥流)异或&#x3D;密文 多次加密 1将上一次加密得到的密文作为下一轮的“明文”输入继续迭代加密 Feistel 1将明文分为左右段（L与R），每个一次加密时将L作为上述的明文，2R作为临时数据与密钥进行代替与换位构成密钥流。3密钥流与L进行异或，最后再将结果左右交换（L、R互换）进入下一轮。4最后一轮不进行左右交换。 扩展Feistel DES特点分组密码 ：明、密文分组长度64比特，密钥64比特（8比特做奇偶校验） 面向二进制数据 对合运算 综合运用了置换、代替、异或 属于典型的Feistel结构 应用世界范围内的广泛应用 被许多国际组织采用为标准 结论其设计目标是安全的 设计精巧、容易实现、使用方便 为国际信息安全发挥重要作用 DES算法 密钥扩展 16轮的Feistel结构 数学描述 算法框架1置换1：64bit筛选剩余56bit，平均分成左右两部分C，D2循环移位：C、D两段分别进行循环移位 3置换2：56bit筛选剩余48bit 置换选择1 1去掉每8位中的最后一位（奇偶校验位）2打乱重排（行列互换） 循环移位 1按照固定好的移位步数进行移位 置换选择2 1按照固定的矩阵从56bit选出48bit 16轮Feistel 8.1 初始置换IP 1按照固定矩阵进行初始置换2对加密没有贡献 8.2 逆初始置换IP-1 1与初始置换互逆 8.3 加密函数F 1扩展置换E：使用重复数据将把32位扩展成48位2S盒：每一个S盒有6个输入4个输出，非线性压缩；3S盒的输入s1s2s3s4s5s6中，s1s6表示行号，4s2s3s4s5表示列号，通过行列序号位置找到矩阵中5的对应值进行变换；DES中唯一的非线性变换；6共有8个S盒；7置换运算P:把数据打乱重排 解密运算 由于DES的对合特性：子密钥的使用顺序与加密时相反，从K16~K1依次使用，即可解密。 10 . 破译 弱密钥 互补对称性","permalink":"http://ryhenkao.github.io/2019/12/19/DES/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"应用密码学复习重点","date":"2019/12/19","text":"密码杂凑函数 密码杂凑函数的定义和安全性：抗原像攻击、抗第二原像攻击、抗碰撞 密码杂凑函数的比特安全性及原理 常用密码杂凑函数及其构造方式、杂凑值长度和安全性 密码杂凑函数的应用 分组密码 对加密通信的攻击：选择明文攻击、选择密文攻击 分组密码的定义 分组密码的两种典型构造：Feistel网络和S-P网络 常用分组密码极其构造方式、密钥长度和安全性 分组密码的模式（加密模式） 序列密码 One-Time Pad 序列密码的概念及其与分组密码的区别 MAC和AEAD 完整性（Integrity）及其对安全性的影响 MAC（消息认证码）算法的定义 AEAD的定义 常用的MAC算法和AEAD模式 密码分析 差分密码分析 线性密码分析 公钥密码 单向函数和单向陷门函数的定义和实例 群、环、域的定义和实例 公钥加密（Public Key Encryption）的定义 欧几里得算法和扩展欧几里得算法 Diffie-Hellman、ElGamal加密算法 椭圆曲线的定义和椭圆曲线算术：点加、倍点、点的标量乘法（Point Scalar Multiplication） 椭圆曲线困难问题ECDLP 椭圆曲线密钥长度和比特安全性的关系 素数和素性测试 素数、本原根（Primitive Roots）的定义 费马小定理、欧拉公式 素数生成算法 Miller-Rabin素性测试算法 RSA算法 RSA加密、RSA签名 为什么教科书中的RSA算法不安全 RSA的填充方案 数字证书与PKI 数字签名的概念与典型数字签名算法 数字证书、根证书、证书链、CA、PKI的概念，通过浏览器观察网站的证书链，了解现实中证书的各个域、DV/EV/OV证书的区别 基于身份的密码（Identity-Based Cryptography）的定义、典型构造、应用以及和传统公钥密码/PKI的区别 数学困难问题 离散对数问题、椭圆曲线离散对数问题、整数分解问题、DH问题、ECDH问题、RSA问题 平滑数的概念及其作用 大步小步法和Pohlig-Hellman算法 硬件安全 密码硬件安全等级1~4级的主要特征 侧信道攻击的种类 密文计算算法 同态加密、基于属性的加密（Attribute-Base Encryption）、可搜索加密、秘密共享/秘密分割、零知识证明、承诺、隐私信息获取（PIR）、不经意传输（OT）的基本概念和应用场景 典型同态加密算法支持的密文计算能力（明文类型和支持的计算类型、数量）","permalink":"http://ryhenkao.github.io/2019/12/19/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-122 买卖股票的最佳时机II","date":"2019/12/11","text":"思路：这道题看似跟上一题很类似（实际上也确实可以用上一题的解法），但是还有更简单的方法，对题目分析可以看出在同一天中是可以先将昨天买入的股票卖出然后再次买入的，这样的话我们就可以不用关心什么时候是最高点了（不用非得在最高价卖出）贪心法：只要今天的价格小于明天的价格，就在今天买入明天卖出（开了上帝视角的炒股神技？！） 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 if len(prices)&lt;&#x3D;1:4 return 05 max_profit&#x3D;06 for i in range(1,len(prices)):7 if prices[i]&gt;prices[i-1]:8 max_profit+&#x3D;prices[i]-prices[i-1]9 return max_profit","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-122/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-121 买卖股票的最佳时机","date":"2019/12/11","text":"双指针遍历:思路：在遍历数组的同时，维护两个指针，一个指针指向当前遍历过的最小值（股票的最低价），另一个指针指向当前可以得到的最大收益。通过维护两个指针我们可以仅在一次遍历数组的过程中得出答案 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 min_price &#x3D; float(&#39;inf&#39;)4 max_profit &#x3D; 05 for i in range(len(prices)):6 min_price &#x3D; min(prices[i], min_price)7 max_profit &#x3D; max(max_profit, prices[i]-min_price)8 return max_profit 动态规划法：思路：实际上，这是一个典型的动态规划问题，首先我们需要一个数组diff用来保存股票每天的变化情况，然后最重要的是找到动态规划的状态转移方程:dp[i]=max(0,dp[i-1]+diff[i])最后我们只需要从数组dp[]中找到最大值即可 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 if len(prices)&lt;&#x3D;1:4 return 05 diff &#x3D; [0 for _ in range(len(prices)-1)] #diff数组记录股票每两天之间差值6 for i in range(len(prices)-1):7 diff[i] &#x3D; prices[i+1]-prices[i]8 dp &#x3D; [0 for _ in range(len(prices)-1)] #dp数组用于动态规划9 dp[0] &#x3D; max(0,diff[0])10 max_profit &#x3D; dp[0]11 for i in range(1, len(prices)-1):12 dp[i] &#x3D; max(0, diff[i]+dp[i-1])13 max_profit &#x3D; max(max_profit, dp[i])14 return max_profit","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-121/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-119 杨辉三角II","date":"2019/12/11","text":"思路：与上一篇杨辉三角的解题思路相同，循环过程中需要记录上一层的数值，然后通过上一层的值求出当前层的数值；不同点在于这次我们只需要构造到题目要求的第K层，然后直接返回第K层的数组就行了 代码：1class Solution:2 def getRow(self, rowIndex: int) -&gt; List[int]:3 4 for i in range(rowIndex+1):5 now&#x3D;[1]*(i+1)6 if i&gt;&#x3D;1:7 for k in range(1,i):8 now[k]&#x3D;pre[k-1]+pre[k]9 pre&#x3D;now10 11 return now","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-119/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-118 杨辉三角","date":"2019/12/11","text":"思路：很明显我们首先需要使用一个for循环来构造numRows个数组来表示三角中的每一层。然后我们开始处理每一层中的元素，根据杨辉三角的构造方式，每一层的第一个以及最后一个元素的值等于1，其余的元素（假设脚标为i）的值就是上一行元素i（右上角）的值与上一行元素i-1（左上角）的值相加得出的 代码：1class Solution:2 def generate(self, numRows: int) -&gt; List[List[int]]:3 4 res&#x3D;[]5 if numRows&#x3D;&#x3D;0:6 return res7 for i in range(0,numRows):8 now&#x3D;[1]*(i+1)9 if i&gt;&#x3D;2:10 for k in range(1,i):11 now[k]&#x3D;pre[k-1]+pre[k]12 res.append(now)13 pre&#x3D;now14 return res","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-118/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-112 路径总和","date":"2019/12/11","text":"思路：在二叉树中搜索符合条件的路径，首先的思路就是通过DFS（深度优先搜索）对二叉树进行遍历，只要找到了符合条件的路径，返回结果True，否则返回False题目中我们需要考虑的两个约束条件：1.节点值的总和等于sum；2.路径必须是从根节点到叶子节点 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:10 if not root:11 return False12 if root.val&#x3D;&#x3D;sum: #判断节点值与sum的关系13 if not root.left and not root.right: #该节点是否为叶子节点14 return True15 sum &#x3D; sum - root.val16 left &#x3D; self.hasPathSum(root.left,sum) #递归搜索左右子树17 right &#x3D; self.hasPathSum(root.right,sum)18 return left or right","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-112/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-111 二叉树的最小深度","date":"2019/12/11","text":"思路：和之前做过的求二叉树深度的题目一样，只不过这次返回的是根节点到叶子节点之间最小的距离，同样使用DFS的思想找到叶子节点，并且同时计算距离即可。 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def minDepth(self, root: TreeNode) -&gt; int:10 if root:11 if root.left and root.right:12 return 1+min(self.minDepth(root.left),self.minDepth(root.right))13#节点存在左右子树的时候，返回较小的深度值14 elif root.left:15 return 1+self.minDepth(root.left) #节点只有一棵子树时，该子树的最小深度就是二叉树的最小深度16 elif root.right:17 return 1+self.minDepth(root.right)18 else:19 return 120 else:21 return 0","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-111/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-110 平衡二叉树","date":"2019/12/11","text":"思路：根据平衡二叉树的定义：每一个节点的左右两个子树高度差的绝对值不超过1，我们可以首先想到的是需要一个计算二叉树高度的函数，这应该是一个我们非常熟悉的函数，通过DFS的方式计算二叉树高度。由于“每一个节点”都满足定义，于是我们可以很快想到采用——递归，对每一个节点都采用相同的方法进行判断，判断是否每个节点的左右子树高度差绝对值小于等于1 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isBalanced(self, root: TreeNode) -&gt; bool:10 def height(root:TreeNode,depth):11 if root&#x3D;&#x3D;None:12 return depth13 elif root.right&#x3D;&#x3D;None and root.left&#x3D;&#x3D;None:14 return depth+115 else:16 left&#x3D;height(root.left,depth+1)17 right&#x3D;height(root.right,depth+1)18 depth &#x3D; max(left,right)19 return depth2021 if root&#x3D;&#x3D;None:22 return True23 left &#x3D; self.isBalanced(root.left)24 right &#x3D; self.isBalanced(root.right)25 if left and right:26 flag&#x3D; abs(height(root.left,0)-height(root.right,0))&lt;&#x3D;127 return flag28 return False","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-110/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-108 有序数组转化为二叉搜索树","date":"2019/12/11","text":"思路：首先对于二叉搜索树：所有的节点满足该节点的左子节点值小于该节点值，该节点的右子节点值大于该节点值。并且根据二叉搜索树的特点：中序遍历一棵二叉搜索树所得序列是一个升序的有序数组。从这个特点反推，这棵二叉搜索树的根节点就应该是有序数组的中间点，每棵子树的根节点也都是被分割（除去中间节点的左右两个子数组）以后的子数组的中间点。综上我们得出了构造二叉搜索树的递归算法 代码：1# class TreeNode:2# def __init__(self, x):3# self.val &#x3D; x4# self.left &#x3D; None5# self.right &#x3D; None67class Solution:8 def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:9 if not nums:10 return None11 else:12 mid &#x3D; len(nums)&#x2F;&#x2F;213 Tree&#x3D;TreeNode(nums[mid])14 nums_left&#x3D;nums[0:mid]15 nums_right&#x3D;nums[mid+1:len(nums)]16 Tree.left&#x3D;self.sortedArrayToBST(nums_left)17 Tree.right&#x3D;self.sortedArrayToBST(nums_right)1819 return Tree","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-108/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-104 二叉树的最大深度","date":"2019/12/11","text":"思路：设定一个计数值depth记录当前深度，采用深度优先遍历，最后比较左右子树深度，返回深度较大的depth值 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def getDepth(self, root, depth):10 if not root:11 return depth #节点为空则返回当前深度12 elif not root.left and not root.right:13 return depth+1 #节点不为空且有子节点，则深度值+114 l&#x3D;self.getDepth(root.left,depth+1) #深度优先遍历左子树15 r&#x3D;self.getDepth(root.right,depth+1) #深度优先遍历右子树1617 return max(l,r) #返回较大的深度值181920 def maxDepth(self, root: TreeNode) -&gt; int:21 if not root:22 return 023 depth&#x3D;024 depth&#x3D;self.getDepth(root,depth)25 return depth","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-104/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-101 对称二叉树","date":"2019/12/11","text":"迭代法：思路：层次遍历的每一层的节点，每层存入一个数组中，若二叉树对称，每层都是一个回文数 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isSymmetric(self, root: TreeNode) -&gt; bool:10 if not root:11 return True12 queue&#x3D;[root]13 while(queue):14 next_queue&#x3D;list() #存储下一层的节点（从左至右）15 layer&#x3D;list() #存储当前层的节点值16 for node in queue:17 if not node:18 layer.append(None)19 continue20 next_queue.append(node.left)21 next_queue.append(node.right)2223 layer.append(node.val)2425 if layer !&#x3D; layer[::-1]: #回文数判定26 return False27 queue &#x3D; next_queue28 return True 递归法：思路：对每一层递归，首先两个节点必须存在，对于被检查的两个节点值必须相等。然后处理镜像：对于一对兄弟节点，左节点的右（左）子节点与右节点的左（右）子节点相等，递归检查 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isSymmetric(self, root: TreeNode) -&gt; bool:10 def check(node1,node2):11 if not node1 and not node2:12 return True13 elif not node1 or not node2:14 return False15 if node1.val !&#x3D; node2.val:16 return False17 return check(node1.left,node2.right) and check(node1.right,node2.left)1819 return check(root,root)","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-101/","photos":[]},{"tags":[],"title":"Hello World","date":"2019/12/06","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"http://ryhenkao.github.io/2019/12/06/hello-world/","photos":[]}]}