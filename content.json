{"meta":{"title":"Ryhen'blog |Code|Life|Love","subtitle":"","description":"","author":"Ryhen Kao","url":"http://ryhenkao.github.io","root":"/"},"posts":[{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"数字证书与PKI","date":"2020/01/01","text":"数字签名数字签名的基本概念·消息认证可以用于保护信息交换双方不受第三方的攻击，但是无法处理通信双方自身发生的攻击，而数字签名用于解决这类问题 · 签名是证明当事者的身份及数据真实性 · 书面签名得到了司法部门的支持 · 完整数字签名应满足三个条件： 1签名者事后不能够抵赖自己的签名2任何其他人不能够伪造签名3如果当时的双方关于签名的真伪发生争执，能够在公正的仲裁者面前通过验证确认其真伪 数字签名的模型· 施加签名：算法为SIG,产生签名的密钥为K，被签名的数据为M，产生的签名信息为S 1S &#x3D; SIG(M,K) · 验证签名：算法为VER，用于鉴别S的真假 1VER(S,K) &#x3D; TRUE ,when S&#x3D;SIG(M,K)2 &#x3D; FALSE,when S≠SIG(M,K) · 签名S只能由签名者产生且签名者不可抵赖 · 收信者可以验证签名者、签名日期和时间 · 签名者应该有办法鉴别收信者所出示的是否是自己的签名。签名者有自卫的能力 · 签名应该能由第三方进行仲裁，解决争执 公钥密码算法实现数字签名· 对于一个公钥密码，满足： 1E(D(M,Kd),Ke)&#x3D;M &#x2F;&#x2F;发送方先使用私钥对M进行“解密”运算，再由接收方通过公钥进行“加密”运算进行验证 则可以保证数据的真实性 · 典型的数字签名算法：RSA、ElGamal、椭圆曲线密码等 数字证书数字证书的概念· 数字证书是一个包含有 用户公钥、时间戳等附加信息以及认证方（可信的签证机构CA）签名的数字文件 · Certificate: { id || pk || sign(id || pk) || signer } · 证书附加信息： 1版本号2序列号：一个整数用于在CA中唯一标志证书3发行商4主体唯一标志5签名算法标志6证书主体名7证书主体公钥信息8有效期 CA (Certificate Authority)· CA称为证书授权中心，是数字证书发放和管理的机构 证书链· 证书被分为root certificates（根证书） 和 intermediates certificates，相应的CA也分成root CA 和intermediate CA · CA的组织结构是一个树型结构，一个root CA下有多个intermediate CA，而他们都可以颁发证书给用户。 · 证书链的定义：证书链也成为认证链，它是最终实体为根证书的一系列证书组成的。 · 可以通过证书的发行商向前追溯，也就是沿着证书链追溯到可信赖的CA的根（root） 根证书· 根证书是CA认证中心自己给自己颁发的的证书，是证书信任链的七十点。安装根证书意味着对这个CA认证中心的信任 PKI (Public Key Infrastructure)· PKI公钥基础设施，是目前网络安全建设的基础与核心 · 在密码学中，PKI是指将公钥与相应的个体或是组织绑定起来的合约（arrangement） · 其中绑定的方式是通过CA的证书注册以及颁发过程实现的 HTTPS的证书· DV型（域名型）：属于最初级的证书，仅需要验证域名的管理权限即可。一般都是通过向域名注册时留下的管理员邮箱发送验证邮件进行验证。 · OV型（企业型）：需要验证企业的真实性和域名的管理权限 · EV型（增强型）：需要验证域名管理权限以及企业真实性，还需要提供银行的开户许可证上的开户行名称 基于身份的密码（Identity-Based Cryptography）定义· 是一种非对称密码体系，与遗忘的公钥密码系统不同点在于可以使用任意的字符串作为用户的公钥，如个人的身份标识、电话号码等 · 不需要CA将用户身份与用户的公钥进行绑定 典型构造· PKG 私钥生成：系统的PKG中心拥有一对主密钥master key，它公布主密钥的公钥，自己保留主密钥的私钥。 · public-key = F(private-key) · private-key = F(master-key, public-key) 流程· 初始化 1在PKG上输入一个安全参数t，生成系统参数params以及PKG的主密钥master-key · 生成私钥 1在PKG上输入系统参数params以及主密钥master-key以及用户ID（任意字符串），生成用户私钥Did · 加密 1输入系统参数params以及接收方的公钥ID（身份相关字符串），对明文M进行加密，获得密文C · 解密 1接收方使用系统参数params，以及自己的私钥Did对密文C解密，得到明文M 应用· 无需密钥和证书管理就可以替代PKI的作用 · 与传统公钥密码/PKI的区别· ·","permalink":"http://ryhenkao.github.io/2020/01/01/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8EPKI/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"硬件安全","date":"2020/01/01","text":"##硬件安全等级的划分与主要特征 FIPS 140-2 Level 1安全级别1提供的是最低的安全级。规定了密码模块的基本要求（如：至少应使用一种已核准的算法或安全功能）。除了生产级组件的基本要求之外安全级别1的加密模块中不需要任何特定的物理安全机制。安全级别1加密模块实例：个人计算机PC的机密板 FIPS 140-2 Level 2安全级别2通过要求显示篡改证据的功能（包括为了确保对明文加密密钥和关键安全参数的物理访问而必须破解的篡改图层或密封），改进了安全级别1密码模块的物理安全机制：加上了盖子或是门以防止未经授权的物理访问 ###FIPS 140-2 Level 3· 安全级别3试图阻止入侵者访问加密模块中保存的CSP（关键安全参数） · 安全级别3的物理安全机制包括使用兼顾的外壳和篡改检测/响应电路。当密码模块的盖板被打开时会将所有的纯文本CSP归零 ###FISP 140-2 Level 4· 在安全级别4上，物理安全机制在加密模块的周围提供了完整的包覆，意在检测并响应所有未经授权的物理访问。 · 安全级别4加密模块对于处在不受保护的物理环境中的运行（operation）非常有用。 侧信道攻击的种类信号发射· 通过计算机屏幕发出的射频可以检测出正在显示的内容 · 可见光的反射可以用来重建显示器的内容 · 这类攻击要求攻击者的接收器足够的接近以检测信号 声音发射· 攻击者利用用户在键盘上打字的录音来重建键入的内容 · 每个按键在产生的声音上都有细微的差别，并且某些按键的使用频率相较于其他按键更高 · 在训练了高级神经网络去识别单个按键之后，他们的攻击方式平均可以识别79%的按键输入 光子侧信道通过热量获取电脑信息通过计算机缓存获取信息","permalink":"http://ryhenkao.github.io/2020/01/01/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"序列密码","date":"2020/01/01","text":"序列密码的基本概念 定义：明文、密文、密钥都是以位（bit）或是字符（每8bit）的形式进行加密 为了安全，密钥必须有足够长度，以防止穷举攻击 密钥需要具有随机性，为此采用一个短的种子密钥，配合密钥产生算法生成密钥 模型 （One-Time Pad）香农信息论中证明了“一次一密”的绝对安全，序列密码可以从现实上逼近“一次一密” 加密运算最简单 安全性取决于密钥序列的产生算法 核心密码的主流 分类 同步序列密码： 密钥序列产生算法与明文（密文）无关，所产生的密钥序列也与明文（密文）无关 通信过程中，通信双方必须保持精确同步，接收方才能正确解密 对失步敏感，能够容易检查到插入、删除、重播等攻击 没有错误传播 区分：错误、失步 自同步序列密码： 密钥序列产生算法与明文（密文）相关，则产生的密钥序列与明文（密文）相关设密钥序列产生器有n位存储，则加密时1位密文错误将影响后续的n个密文错误， 在此之后恢复正确。 解密时同理。 线性移位寄存器序列密码反馈函数F(s0,s1,…,sn-1)。 若函数F为（非）线性函数，则称为（非）线性移位寄存器。 每一个时刻移位寄存器的取值称为一个状态 线性移位寄存器n级线性移位寄存器最多有2^n个不同状态。若其初始状态为零，则其后续状态恒为零。若其初始状态不为零，则其后续状态也不为零。因此n级线性移位寄存器的状态周期&lt;=2^n-1，其输出序列的周期&lt;=2^n-1。 只要选择合适的连接多项式g(x)便可以使线性移位寄存器的输出序列周期达到最大值2^n-1，并称此时的输出序列为最大长度线性移位寄存器输出序列，简称为m序列 仅当连接多项式g(x)是本原多项式，其移位状态寄存器的输出序列为m序列 已经证明，对于任意的正整数n我们都可以求得其本原多项式 m序列具有良好得随机性： 在一个周期内，0和1出现的次数接近相等。0出现的次数2^(n-1)-1,1出现的次数2^(n-1) *游程：序列中连续i个1为长度等于i的1游程，体现序列中的随机分布程度；同理，序列中连续的i个0为长度等于i的0游程* 1游程和0游程的数目各占一半，且长度相等的0/1游程数量相等线性移位寄存器序列密码除最后一位以外新老状态之间存在错一位的关系s0’=s1，s1’=s2,… 使用已知明文攻击，在已知一段2n位明密文对的情况下可以求出一段2n位连续密钥。相当于可以写出连续的n+1个状态 非线性序列密码 非线性移位寄存器序列 线性移位寄存器进行非线性组合 利用非线性分组码产生非线性序列 非线性移位寄存器序列令反馈函数F为非线性函数 称周期达到最大为2^n时，称非线性移位寄存器序列为M序列M序列的0/1分布和游程均是均匀的且周期最大 非线性移位寄存器的空间（2^2^n）远远大于线性移位寄存器的空间（2n-1） 对线性移位寄存器进行非线性组合设计重点在于非线性组合 RC4序列密码应用最广泛的商用序列密码 基于非线性数据表变换的序列密码 以足够大的数据表作为基础，对表进行非线性变换，产生非线性的密钥序列 适合软件实现 RC4使用256字节的S表和两个指针I和J 将RC4视为一个有限状态自动机 下一状态定义输出函数定义S表初始化","permalink":"http://ryhenkao.github.io/2020/01/01/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"哈希函数","date":"2020/01/01","text":"哈希函数Hash函数的概念Hash函数的作用· 具有极强的错误检测能力· 用Hash码作为消息认证码（MAC）· 用Hash函数辅助数字签名· 辅助随机数的产生· 保护口令秘密性· Hash函数与加密函数不同的是它不使用密钥· 由可变长度输入生成定长输出· 对Hash函数的要求 1. H可应用于任意大小的数据块 2. H产生定长的输出 3. 对于任意给定的x，计算H(x)容易 4. 对于给定hash值H(x)=b，在计算原始值x时不可行——单向性 5. 对于给定输入x，找到一个值y满足y≠x且H(x)=H(y)在计算上不可行——抗弱碰撞性 6. 找到任何满足H(x)=H(y)的偶对（x，y）在计算上不可行——抗强碰撞性HASH函数的安全性· 抗原像攻击：对任何给定的hash函数值H(x)=h，已知h找到x是不可行的· 抗第二原像攻击：对于任何给定数据x，找到一个值y满足y≠x且H(x)=H(y)在计算上不可行· 抗碰撞：找到任何满足H(x)=H(y)的偶对(x,y)在计算上是不可行的 比特安全性· 生日悖论：一个教室中，最少应有多少学生才使至少有两个人具有相同生日的开率不小于1/2？· 假定hash函数H有2^m种可能的输出（即输出摘要值为m比特），H作用域k个随即输入，那么k为多少时至少有一个重复出现（能找到输入x和y，有H(x)=H(y)）,的概率大于0.5· 结论：k=2^(m/2)· 对输出为n比特的hash函数，弱碰撞攻击穷举需要的复杂度为O(2^n)· 对输出为n比特的hash函数，强碰撞攻击穷举只需要复杂度为O(2^(n/2))· MD5 的比特安全性为 128/2=64 比特· SHA-1的比特安全性是 160/2=80 比特· SHA-256的比特安全性是 256/2=128 比特 HASH函数构造Merkle-Damgard（MD）结构· HASH函数应用MD5SHA-1SHA-2SM3One-Time Password(OTP)Bitcoin Block ChainServer-side Password Protection","permalink":"http://ryhenkao.github.io/2020/01/01/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"MAC与AEAD","date":"2020/01/01","text":"MAC与AEAD完整性及其对安全性的影响· 完整性是指消息的接收者应该能够验证在传送的过程中消息没有被修改；攻击者不可能用假消息代替合法消息 · 对安全性的影响：缺少完整性保护的系统会受到 内容修改 、 顺序修改 和 计时修改 的攻击 · 内容修改：对消息内容进行修改，包括插入、删除、转换和修改 · 顺序修改： 对通信双方的消息顺序进行修改，包括插入、删除、重新排序 · 计时修改： 对消息的重播和延时 MAC（消息认证码）MAC的定义· MAC利用密钥来生成固定长度的短数据块，并将该数据块附加在消息之后 1MAC &#x3D; C（K，M）2&#x2F;&#x2F;其中M为明文消息，C为MAC函数，K为共享密钥 · 将消息和MAC一起发送给消息接收方。接收方对消息使用相同的密钥K进行相同的运算得出MAC，并且将计算出的MAC与消息附加的MAC进行比较。 · 一般来说，MAC函数与加密类似，但是MAC算法要求不可逆，而加密算法必须是可逆的 常用的MAC算法HMAC· HAMAC是基于hash算法的消息认证码 · HMAC的算法描述如下 1HMAC(K,M) &#x3D; H[(K&#39;⊕ opad) || H[(K&#39;⊕ipad)||M]]2&#x2F;&#x2F;在K左侧填充0使其达到分组长度，记为K’ · HMAC流程如下 11. 在K左边填充0，得到b位的K’22. K&#39;与ipad执行异或运算得到长度为b位的分组Si33. 将M附于Si之后44. 将H作用于第3步的结果上55. 将K&#39;于opad执行异或操作产生长度为b位的分组S066. 将第4步得到的Hash码依附于S0之后77. 将H作用域第6步的结果，输出最终的结果为所需要的MAC值 CBC-MAC· 基于分组密码AES实现的MAC · 加密步骤 11. 首先将数据按照l比特分组，最后不足分组长度的使用固定的pad补足，得到分组D1D2...Dn22. 将D1与初始向量IV异或之后进行加密得到第一组密文C133. 将D2与上一步骤的结果C1异或之后及逆行加密得到C244. 之后的数据以此类推，得到Cn，最终的Cn就是该消息认证码 · CBC-MAC的安全性 1每一个密钥都只能被用于固定长度和已知长度的消息2如果使用的分组密码算法是安全的，则CBC-MAC对于固定长度的消息是安全的3CBC-MAC对于可变长度的消息是不安全的 AEADAEAD的定义· AEAD是一种同时提供保密性以及完整性（认证）的加密系统。 AEAD的常用模式· 对于消息M有四种同时提供保密性以及完整性的通用方案 11. 先Hash再加密。对于明文M使用Hash函数计算H(M),再将M与H(M)一起加密：E(K,(M,H(M)))232. 先认证再加密。使用两个密钥K1，K2。先计算明文M的MAC值T&#x3D;MAC(K1,M),再将MAC值与明文一起加密：E(K2,(M,T))453. 先加密再认证。使用两个密钥K1，K2。先对明文M加密得到密文C&#x3D;E(K2,M),再计算密文C的MAC值T&#x3D;MAC(K1,C)674. 独立进行加密和认证。","permalink":"http://ryhenkao.github.io/2020/01/01/MAC%E4%B8%8EAEAD/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"RSA","date":"2020/01/01","text":"RSA加密算法RSA签名RSA的安全性RSA可能受到如下5种方式的攻击： · 穷举攻击：试图穷举所有可能的密钥 · 数学攻击：试图分解两个素数的乘积 · 基于硬件故障的攻击：这种方法应用产生签名过程中处理器发生的故障 · 计时攻击：依赖于解密算法的运行时间 · 选择密文攻击：利用了RSA算法的性质 RSA抗穷举攻击的方式是使用大的密钥空间，所以e和d的位数越大越好，但是密钥产生的过程和加/解密过程都包含了复杂的计算，密钥越大，系统的运行速度越慢 对RSA的攻击方式· 攻击思路：分解n为两个素因子p,q。这样可以计算出φ(n)=(p-1)(q-1)，从而可以确定d=e^(-1) mod φ(n) · 现在已知的，从e和n确定d的算法时间复杂度至少和因子分解问题一样。因此可以将因子分解的性能作为基准来评价RSA的安全性 · 20世纪90年代一直采用的是二次筛法来进行因子分解。 · 而新的算法：一般数域筛法，可以对RSA-130进行攻击，能够分解比RSA-129更大的数而且计算代价仅为二次筛法的20% RSA的填充方案· 为了防止RSA受到选择密文攻击，RSA公司推荐使用 最优非对称加密填充（OAEP）的方案 · OAEP算法： 11. 明文M被填充padding22. 可选参数集P作为hash函数的输入，输出产生H(P),并用0填充以达到期望长度33. 将M+padding+H(P)放入数据块DB内44. 选择一个随机种子作为hash函数的输入，该hash函数称为掩码生成函数（MGF）55. 将输出的哈市值与DB做异或运算，产生掩码DB（maskedDB）66. 掩码DB作为MGF的输入，产生一个hash值，该hash值与随机种子进行异或，产生掩码种子77. 掩码种子和掩码DB连接起来构成消息EM，完成消息的填充88. 最后直接用RSA对EM进行加密即可","permalink":"http://ryhenkao.github.io/2020/01/01/RSA/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"AES","date":"2020/01/01","text":"AES概况NIST公开征集 1998~2000年经历三轮审查 2001年最终选定一个算法并制定其位标准设计要求 安全性：可抵御目前已知攻击 实用性：适应各种应用环境 扩展性：分组长度和密钥长度可扩展 特点 分组密码：现在使用明文密文长度为128位，密钥长度可变（128/256等等） 面向二进制： 能够加解密任何计算机数据 不是对合运算： 加解密使用不同的算法（但是结构基本一样） 综合运用多种密码古典密码技术： 置换、代替、异或 整体结构：采用SP结构（S盒+P置换），基本轮函数循环迭代 AES的子表示与运算 AES的数据处理单位是字节和字 一个字=4个字节=（4×8bit）32bit 一个字可以表示为系数取自GF(2^8)上的次数低于4次的多项式状态 加解密状态的中间数据 以字节为元素的矩阵或是二维数组 Nb——明文所含的字数 Nk——密钥所含的字数 Nr——迭代轮数 轮函数共进行10轮变换 前9轮成为标准轮函数 最后一轮非标准轮函数 标准轮函数S盒变换+P置换（行移位变换+列混合变换）+轮密钥加 非标准轮函数S盒变换+行移位变换+轮密钥加 S盒变换AES的唯一非线性变换 AES的S盒输入输出都是8位，是非线性置换 AES使用16个相同的S盒（一个S盒对应一个状态，一个状态对应一个字节） S盒操作 将输入字节用其GF(2^8)上的逆元素表示（非线性变换） 把输入的字节看成GF(2^8)上的元素 求出其在域上的逆元素 用逆元素代替原输入字节 对第一步的结果做仿射变换（线性变换） 行移位 对状态的行进行循环移位 第0行不移位，第1行移C1自己，第二行移C2字节，第三行移C3字节 C1~3的取值由下表规定 Nb C1 C2 C3 4 1 2 3 6 1 2 3 行移位变换属于置换，是线性变换，本质在于把数据打乱重排，起扩散作用 列混合 列混合变换把状态看作GF(2^8)上的 一个多项式a(x)，乘以一个固定的多项式c(x)，并模x^4+1 c(x) = 03x^3 + 01x^2 + 01x + 02 列混合变换属于线性变换，起扩散作用 c(x)与x^4+1互素，保证了c(x)存在逆多项式d(x)，只有存在d(x)才能进行解密 轮密钥加 轮密钥与状态进行模2相加 轮密钥根据密钥产生算法生成 轮密钥长度等于数据块长度 轮密钥生成 密钥扩展 轮密钥选择 密钥扩展轮密钥选择 根据分组的大小，一次从扩展密钥中去除轮密钥 前Nb个字作为轮密钥0，接下来Nb个字作为轮密钥1，…… AES的解密AES的加密算法不是对合运算；但是AES的解密算法和加密算法的结构相同把加密算法的每一个变换变成其逆运算即可 AES的基本逆变换 轮密钥加 轮密钥加变化的逆就是其本身 行移位变换 行移位变换的逆是状态的后三行分别移动（Nb-Ci）位，i=1，2，3 列混合变换 把状态的每一列乘以一个固定多项式d(x),d(x)=c(x)^-1 S盒 第一步：进行逆仿射变换 第二步：把每个字节用其在GF(2^8)中的逆来代替 解密的密钥扩展 第一步：使用与加密算法相同的密钥扩展 第二步：把InvMixColumn（逆列混合变换）用到除去第一和最后一轮意外的所有轮密钥上 AES的实现基于算法的软件实现 基于查表的软件实现 S盒查表 列混合查表 轮函数查表AES的安全性能抵御目前所有的已知攻击 穷举攻击、差分攻击、线性攻击、 Square攻击、侧信道攻击目前存在低于穷举复杂度的攻击方式，但是还不能对AES造成本质威胁","permalink":"http://ryhenkao.github.io/2020/01/01/AES/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"公钥密码","date":"2019/12/28","text":"公钥密码的基本思想传统密码的优缺点 优点1理论和实践都很成熟2安全容易把握3加解密速度快 缺点1收发双方持有相同密钥，Ke&#x3D;Kd，密钥分发困难，在网络环境更突出2不能方便地实现数字签名，商业等应用也不方便 公开密钥密码的基本思想 将密钥K一分为二：Ke和Kd。Ke专门加密，Kd专门解密，且Ke与Kd不相等 由Ke不能计算出Kd，于是可以将Ke公开，使密钥Ke分配简单 由于Ke与Kd不相等且由Ke不能计算出Kd，所以Kd可以作为用户的指纹，方便地实现数字签名 公开密钥密码的基本条件 E()和D()分别是加密和解密算法 保密条件： D和E互逆，即D(E(M))=M 安全条件：Ke与Kd不相等且由Ke不能计算出Kd 实用条件：E和D都高效 保真条件：E(D(M))=M 满足条件1、2、3可以用于保密；满足条件2、3、4可以用于保真（数字签名）；四个条件同时满足即可用于保密和保真 公钥密码的理论模型 1.单向函数：y=f(x)需要满足以下两个函数 1· 如果对于给定的x，计算y&#x3D;f(x)很容易2· 对于给定的y，要计算出x&#x3D;f^-1(y)很难 2.利用单向函数构造密码 1· 用正变换做加密，加密效率高2· 用逆变换做解密，安全，攻击者不可破译3· 但是合法的收信者也无法解密 3.单向陷门函数 设函数y=f(x)且f具有陷门，满足以下两个条件称f(x)的单向陷门函数 1· 如果对于给定的x，计算出y&#x3D;f(x)很容易2· 对于给定的y，如果不掌握陷门要计算出x很困难；如果掌握了陷门要计算出x很容易 4.利用单向陷门函数构造密码 1· 用正变换做加密，加密效率高2· 用逆变换做解密，安全3· 把陷门作为密钥，且只分配给合法用户。确保合法用户能够方便解密，而非法用户不能破译 5.单向函数的研究现状 理论上，不能证明单向函数一定存在 实际上， 密码学认为之哟啊函数的单向性足够应用就行 已知单向性足够的函数： 1· 大合数的因式分解问题2· 有限域上的离散对数问题3· 椭圆曲线离散对数问题 公钥密码的基本工作方式· 设M为明文，C为密文，E为加密算法，D为解密算法 · 每个用户都配置一对密钥Ke（公开的加密密钥）和Kd（保密的解密密钥） · 将所有哦用户的公开加密密钥Ke存入共享的密钥数据库PKDB · 保密的解密密钥Kd由用户妥善保管 1.确保数据的秘密性： 1发送方：2 1.A查找PKDB（公钥数据库），找到B的公开密钥KeB3 2.A用KeB加密密文M得到密文C：C&#x3D;E(M,KeB)4 3.A将C发送给B5接收方：6 1.B接收C7 2.B用自己的KdB解密，得到明文M&#x3D;D(C,KdB) 安全性分析：保证了数据的秘密性，但是不确保数据的真实性，保密但是不保真 2.确保数据的真实性： 1发送方：2 1.A用自己的KdA对M进行解密，得到C&#x3D;D(M,KdA)3 2.A将C发送给B4接收方：5 1.B接收C6 2.B通过PKDB查询A的公开加密密钥KeA7 3.B使用KeA加密C，得到明文M&#x3D;(C,KeA) 安全性分析：保证了真实性，但是不确保数据的秘密性，保真但是不保密 3.确保秘密性与真实性 1发送方：2 1.A首先用KdA对M解密，得到中间密文S3 2.A查PKDB，得到B的KeB4 3.用Keb对S进行加密得到C5接收方：6 1.B接收C7 2.B用自己的KdB解密C得到中间密文S8 3.B查PKDB，得到A的KeA9 4.用KeA对密文S进行加密得到明文M 安全性分析：保证了真实性与秘密性 ElGamal建立在离散对数问题的基础上· 随机选择一个大素数p，要求（p-1）具有大素数因子。选择一个模p的本原根a，并且公开a和p作为密码的基础参数 · 用户随机生成一个正整数d，2≤d≤p-2，作为私钥 · 用户计算 y=a^d mod p 得出公钥y 加密将明文M（0≤M≤p-1）加密成密文的过程如下： · 随机的选取一个整数k，2≤k≤p-2 · 计算 1U &#x3D; y^k mod p &#x2F;&#x2F;y是公钥2C1 &#x3D; a^k mod p3C2 &#x3D; UM mod p · 取C=（C1，C2）作为密文 解密将密文（C1,C2）解密过程如下： 1V &#x3D; C1^d mod p2M &#x3D; C2*(V^-1) mod p 得到明文M 安全性· 安全性建立在GF(p)离散对数的困难性之上 · 为了安全考量，p应该在150位以上的十进制数，且(p-1)应该有大素数因子 · d和k都不能太小 · 安全加密和签名所使用的k都必须是一次性的 Diffie-Hellman密钥交换· 目的是使两个用户可以安全地交换密钥，以便在后续的通信中使用该密钥进行消息加密 · 算法有效性建立在离散对数问题求解的困难性上 · 对素数p的本原根a求幂，实现范围从1到p-1的一个置换 D-H密钥交换算法· 存在两个公开的整数：素数q和本原根a · 用户A随机选择一个整数 XA&lt;q 并计算 YA=a^(XA) mod q · 用户B也独立选择一个随机整数 XB&lt;q 并计算 YB=a^(XB) mod q · A和B保持各自的X是私有的，但是对另一方公开Y · 用户A计算 K=(YB)^(XA) mod q，并将其作为密钥 · 用户B计算 K=(YA)^(XB) mod q，并将其作为密钥 最终两个K的计算结果是相同的，也就完成了密钥的确定过程。 1KA &#x3D;(YB)^(XA)mod q2 &#x3D;(a^(XB)mod q)^(XA)mod q3 &#x3D;(a^(XB))^(XA)mod q4KB &#x3D;(YA)^(XB)mod q5 &#x3D;(a^(XA)mod q)^(XB)mod q6 &#x3D;(a^(XA))^(XB)mod q7 &#x3D;(a^(XB))^(XA)mod q &#x3D; KA 椭圆曲线椭圆曲线的定义椭圆曲线的算数1E : Y^2&#x3D; X^3 + AX + B23be an elliptic curve and let P1 and P2 be points on E.45(a) If P1 &#x3D; O, then P1 + P2 &#x3D; P2.67(b) Otherwise, if P2 &#x3D; O, then P1 + P2 &#x3D; P1.89(c) Otherwise, write P1 &#x3D; (x1, y1) and P2 &#x3D; (x2, y2).1011(d) If x1 &#x3D; x2 and y1 &#x3D; −y2, then P1 + P2 &#x3D; O.1213(e) Otherwise, define λ by14 15 if P1&#x3D;P2, then λ&#x3D;(y2-y1)&#x2F;(x2-x1)16 if P1≠P2, then λ&#x3D;(3*x1^2+A)&#x2F;(2*y1)1718then let1920x3 &#x3D; λ^2 − x1 − x2 and y3 &#x3D; λ(x1 − x3) − y1.2122Then P1 + P2 &#x3D; (x3, y3). 椭圆曲线困难问题####椭圆曲线离散对数问题ECDLP给出椭圆曲线上的两点P和Q，求解以P为底Q的对数k ECDLP求解大步小步法 椭圆曲线的安全性椭圆曲线密码的困难性建立在椭圆曲线对数求解问题之上。Pollar rho方法是目前已知最快的椭圆曲线对数求解方法。已知的是，ECC使用的密钥长度比RSA中使用的密钥长度短得多。而且在密钥长度相同时，ECC与RSA执行所需的计算量相差不多。因此，在具有相同安全性的情况下，ECC使用的密钥比RSA更短，计算量也比RSA更少。","permalink":"http://ryhenkao.github.io/2019/12/28/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"数据加密标准 DES","date":"2019/12/19","text":"概念对称加密：加密密钥=解密密钥 序列（流）密码：对明文数据进行逐位（每一比特或是每一字节）进行异或 分组密码： 将明文数据分成等长的若干组再进行处理 分组密码输出块中的每一位都是由（输入块+钥匙）的每一位决定的 方式：代替、置换、异或 产生效果： 1混淆：代替、异或2扩散：移位 特点：良好的扩散性和对插入的敏感性 代替与换位代替（S盒） 1混淆：不同输入导致相同的输出2扩散：输入数据中1bit的变换造成多个bit的输出变换3操作：算术&#x2F;逻辑运算，非线性映射4受计算机字长和计算能力的限制，代替处理的数据宽度有限。需要多个代替模块 换位（置换）permutation 1交换各个数据位的位置 代替+换位=更大规模的混淆与扩散效果 Feistel结构一次加密 1(密钥+临时数据)代替与换位&#x3D;密钥流2(明文+密钥流)异或&#x3D;密文 多次加密 1将上一次加密得到的密文作为下一轮的“明文”输入继续迭代加密 Feistel 1将明文分为左右段（L与R），每个一次加密时将L作为上述的明文，2R作为临时数据与密钥进行代替与换位构成密钥流。3密钥流与L进行异或，最后再将结果左右交换（L、R互换）进入下一轮。4最后一轮不进行左右交换。 扩展Feistel DES特点分组密码 ：明、密文分组长度64比特，密钥64比特（8比特做奇偶校验） 面向二进制数据 对合运算 综合运用了置换、代替、异或 属于典型的Feistel结构 应用世界范围内的广泛应用 被许多国际组织采用为标准 结论其设计目标是安全的 设计精巧、容易实现、使用方便 为国际信息安全发挥重要作用 DES算法 密钥扩展 16轮的Feistel结构 数学描述 算法框架1置换1：64bit筛选剩余56bit，平均分成左右两部分C，D2循环移位：C、D两段分别进行循环移位 3置换2：56bit筛选剩余48bit 置换选择1 1去掉每8位中的最后一位（奇偶校验位）2打乱重排（行列互换） 循环移位 1按照固定好的移位步数进行移位 置换选择2 1按照固定的矩阵从56bit选出48bit 16轮Feistel 8.1 初始置换IP 1按照固定矩阵进行初始置换2对加密没有贡献 8.2 逆初始置换IP-1 1与初始置换互逆 8.3 加密函数F 1扩展置换E：使用重复数据将把32位扩展成48位2S盒：每一个S盒有6个输入4个输出，非线性压缩；3S盒的输入s1s2s3s4s5s6中，s1s6表示行号，4s2s3s4s5表示列号，通过行列序号位置找到矩阵中5的对应值进行变换；DES中唯一的非线性变换；6共有8个S盒；7置换运算P:把数据打乱重排 解密运算 由于DES的对合特性：子密钥的使用顺序与加密时相反，从K16~K1依次使用，即可解密。 10 . 破译 弱密钥 互补对称性","permalink":"http://ryhenkao.github.io/2019/12/19/DES/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"应用密码学复习重点","date":"2019/12/19","text":"密码杂凑函数 密码杂凑函数的定义和安全性：抗原像攻击、抗第二原像攻击、抗碰撞 密码杂凑函数的比特安全性及原理 常用密码杂凑函数及其构造方式、杂凑值长度和安全性 密码杂凑函数的应用 分组密码 对加密通信的攻击：选择明文攻击、选择密文攻击 分组密码的定义 分组密码的两种典型构造：Feistel网络和S-P网络 常用分组密码极其构造方式、密钥长度和安全性 分组密码的模式（加密模式） 序列密码 One-Time Pad 序列密码的概念及其与分组密码的区别 MAC和AEAD 完整性（Integrity）及其对安全性的影响 MAC（消息认证码）算法的定义 AEAD的定义 常用的MAC算法和AEAD模式 密码分析 差分密码分析 线性密码分析 公钥密码 单向函数和单向陷门函数的定义和实例 群、环、域的定义和实例 公钥加密（Public Key Encryption）的定义 欧几里得算法和扩展欧几里得算法 Diffie-Hellman、ElGamal加密算法 椭圆曲线的定义和椭圆曲线算术：点加、倍点、点的标量乘法（Point Scalar Multiplication） 椭圆曲线困难问题ECDLP 椭圆曲线密钥长度和比特安全性的关系 素数和素性测试 素数、本原根（Primitive Roots）的定义 费马小定理、欧拉公式 素数生成算法 Miller-Rabin素性测试算法 RSA算法 RSA加密、RSA签名 为什么教科书中的RSA算法不安全 RSA的填充方案 数字证书与PKI 数字签名的概念与典型数字签名算法 数字证书、根证书、证书链、CA、PKI的概念，通过浏览器观察网站的证书链，了解现实中证书的各个域、DV/EV/OV证书的区别 基于身份的密码（Identity-Based Cryptography）的定义、典型构造、应用以及和传统公钥密码/PKI的区别 数学困难问题 离散对数问题、椭圆曲线离散对数问题、整数分解问题、DH问题、ECDH问题、RSA问题 平滑数的概念及其作用 大步小步法和Pohlig-Hellman算法 硬件安全 密码硬件安全等级1~4级的主要特征 侧信道攻击的种类 密文计算算法 同态加密、基于属性的加密（Attribute-Base Encryption）、可搜索加密、秘密共享/秘密分割、零知识证明、承诺、隐私信息获取（PIR）、不经意传输（OT）的基本概念和应用场景 典型同态加密算法支持的密文计算能力（明文类型和支持的计算类型、数量）","permalink":"http://ryhenkao.github.io/2019/12/19/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-122 买卖股票的最佳时机II","date":"2019/12/11","text":"思路：这道题看似跟上一题很类似（实际上也确实可以用上一题的解法），但是还有更简单的方法，对题目分析可以看出在同一天中是可以先将昨天买入的股票卖出然后再次买入的，这样的话我们就可以不用关心什么时候是最高点了（不用非得在最高价卖出）贪心法：只要今天的价格小于明天的价格，就在今天买入明天卖出（开了上帝视角的炒股神技？！） 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 if len(prices)&lt;&#x3D;1:4 return 05 max_profit&#x3D;06 for i in range(1,len(prices)):7 if prices[i]&gt;prices[i-1]:8 max_profit+&#x3D;prices[i]-prices[i-1]9 return max_profit","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-122/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-121 买卖股票的最佳时机","date":"2019/12/11","text":"双指针遍历:思路：在遍历数组的同时，维护两个指针，一个指针指向当前遍历过的最小值（股票的最低价），另一个指针指向当前可以得到的最大收益。通过维护两个指针我们可以仅在一次遍历数组的过程中得出答案 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 min_price &#x3D; float(&#39;inf&#39;)4 max_profit &#x3D; 05 for i in range(len(prices)):6 min_price &#x3D; min(prices[i], min_price)7 max_profit &#x3D; max(max_profit, prices[i]-min_price)8 return max_profit 动态规划法：思路：实际上，这是一个典型的动态规划问题，首先我们需要一个数组diff用来保存股票每天的变化情况，然后最重要的是找到动态规划的状态转移方程:dp[i]=max(0,dp[i-1]+diff[i])最后我们只需要从数组dp[]中找到最大值即可 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 if len(prices)&lt;&#x3D;1:4 return 05 diff &#x3D; [0 for _ in range(len(prices)-1)] #diff数组记录股票每两天之间差值6 for i in range(len(prices)-1):7 diff[i] &#x3D; prices[i+1]-prices[i]8 dp &#x3D; [0 for _ in range(len(prices)-1)] #dp数组用于动态规划9 dp[0] &#x3D; max(0,diff[0])10 max_profit &#x3D; dp[0]11 for i in range(1, len(prices)-1):12 dp[i] &#x3D; max(0, diff[i]+dp[i-1])13 max_profit &#x3D; max(max_profit, dp[i])14 return max_profit","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-121/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-119 杨辉三角II","date":"2019/12/11","text":"思路：与上一篇杨辉三角的解题思路相同，循环过程中需要记录上一层的数值，然后通过上一层的值求出当前层的数值；不同点在于这次我们只需要构造到题目要求的第K层，然后直接返回第K层的数组就行了 代码：1class Solution:2 def getRow(self, rowIndex: int) -&gt; List[int]:3 4 for i in range(rowIndex+1):5 now&#x3D;[1]*(i+1)6 if i&gt;&#x3D;1:7 for k in range(1,i):8 now[k]&#x3D;pre[k-1]+pre[k]9 pre&#x3D;now10 11 return now","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-119/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-118 杨辉三角","date":"2019/12/11","text":"思路：很明显我们首先需要使用一个for循环来构造numRows个数组来表示三角中的每一层。然后我们开始处理每一层中的元素，根据杨辉三角的构造方式，每一层的第一个以及最后一个元素的值等于1，其余的元素（假设脚标为i）的值就是上一行元素i（右上角）的值与上一行元素i-1（左上角）的值相加得出的 代码：1class Solution:2 def generate(self, numRows: int) -&gt; List[List[int]]:3 4 res&#x3D;[]5 if numRows&#x3D;&#x3D;0:6 return res7 for i in range(0,numRows):8 now&#x3D;[1]*(i+1)9 if i&gt;&#x3D;2:10 for k in range(1,i):11 now[k]&#x3D;pre[k-1]+pre[k]12 res.append(now)13 pre&#x3D;now14 return res","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-118/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-112 路径总和","date":"2019/12/11","text":"思路：在二叉树中搜索符合条件的路径，首先的思路就是通过DFS（深度优先搜索）对二叉树进行遍历，只要找到了符合条件的路径，返回结果True，否则返回False题目中我们需要考虑的两个约束条件：1.节点值的总和等于sum；2.路径必须是从根节点到叶子节点 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:10 if not root:11 return False12 if root.val&#x3D;&#x3D;sum: #判断节点值与sum的关系13 if not root.left and not root.right: #该节点是否为叶子节点14 return True15 sum &#x3D; sum - root.val16 left &#x3D; self.hasPathSum(root.left,sum) #递归搜索左右子树17 right &#x3D; self.hasPathSum(root.right,sum)18 return left or right","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-112/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-111 二叉树的最小深度","date":"2019/12/11","text":"思路：和之前做过的求二叉树深度的题目一样，只不过这次返回的是根节点到叶子节点之间最小的距离，同样使用DFS的思想找到叶子节点，并且同时计算距离即可。 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def minDepth(self, root: TreeNode) -&gt; int:10 if root:11 if root.left and root.right:12 return 1+min(self.minDepth(root.left),self.minDepth(root.right))13#节点存在左右子树的时候，返回较小的深度值14 elif root.left:15 return 1+self.minDepth(root.left) #节点只有一棵子树时，该子树的最小深度就是二叉树的最小深度16 elif root.right:17 return 1+self.minDepth(root.right)18 else:19 return 120 else:21 return 0","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-111/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-110 平衡二叉树","date":"2019/12/11","text":"思路：根据平衡二叉树的定义：每一个节点的左右两个子树高度差的绝对值不超过1，我们可以首先想到的是需要一个计算二叉树高度的函数，这应该是一个我们非常熟悉的函数，通过DFS的方式计算二叉树高度。由于“每一个节点”都满足定义，于是我们可以很快想到采用——递归，对每一个节点都采用相同的方法进行判断，判断是否每个节点的左右子树高度差绝对值小于等于1 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isBalanced(self, root: TreeNode) -&gt; bool:10 def height(root:TreeNode,depth):11 if root&#x3D;&#x3D;None:12 return depth13 elif root.right&#x3D;&#x3D;None and root.left&#x3D;&#x3D;None:14 return depth+115 else:16 left&#x3D;height(root.left,depth+1)17 right&#x3D;height(root.right,depth+1)18 depth &#x3D; max(left,right)19 return depth2021 if root&#x3D;&#x3D;None:22 return True23 left &#x3D; self.isBalanced(root.left)24 right &#x3D; self.isBalanced(root.right)25 if left and right:26 flag&#x3D; abs(height(root.left,0)-height(root.right,0))&lt;&#x3D;127 return flag28 return False","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-110/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-108 有序数组转化为二叉搜索树","date":"2019/12/11","text":"思路：首先对于二叉搜索树：所有的节点满足该节点的左子节点值小于该节点值，该节点的右子节点值大于该节点值。并且根据二叉搜索树的特点：中序遍历一棵二叉搜索树所得序列是一个升序的有序数组。从这个特点反推，这棵二叉搜索树的根节点就应该是有序数组的中间点，每棵子树的根节点也都是被分割（除去中间节点的左右两个子数组）以后的子数组的中间点。综上我们得出了构造二叉搜索树的递归算法 代码：1# class TreeNode:2# def __init__(self, x):3# self.val &#x3D; x4# self.left &#x3D; None5# self.right &#x3D; None67class Solution:8 def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:9 if not nums:10 return None11 else:12 mid &#x3D; len(nums)&#x2F;&#x2F;213 Tree&#x3D;TreeNode(nums[mid])14 nums_left&#x3D;nums[0:mid]15 nums_right&#x3D;nums[mid+1:len(nums)]16 Tree.left&#x3D;self.sortedArrayToBST(nums_left)17 Tree.right&#x3D;self.sortedArrayToBST(nums_right)1819 return Tree","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-108/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-104 二叉树的最大深度","date":"2019/12/11","text":"思路：设定一个计数值depth记录当前深度，采用深度优先遍历，最后比较左右子树深度，返回深度较大的depth值 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def getDepth(self, root, depth):10 if not root:11 return depth #节点为空则返回当前深度12 elif not root.left and not root.right:13 return depth+1 #节点不为空且有子节点，则深度值+114 l&#x3D;self.getDepth(root.left,depth+1) #深度优先遍历左子树15 r&#x3D;self.getDepth(root.right,depth+1) #深度优先遍历右子树1617 return max(l,r) #返回较大的深度值181920 def maxDepth(self, root: TreeNode) -&gt; int:21 if not root:22 return 023 depth&#x3D;024 depth&#x3D;self.getDepth(root,depth)25 return depth","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-104/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-101 对称二叉树","date":"2019/12/11","text":"迭代法：思路：层次遍历的每一层的节点，每层存入一个数组中，若二叉树对称，每层都是一个回文数 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isSymmetric(self, root: TreeNode) -&gt; bool:10 if not root:11 return True12 queue&#x3D;[root]13 while(queue):14 next_queue&#x3D;list() #存储下一层的节点（从左至右）15 layer&#x3D;list() #存储当前层的节点值16 for node in queue:17 if not node:18 layer.append(None)19 continue20 next_queue.append(node.left)21 next_queue.append(node.right)2223 layer.append(node.val)2425 if layer !&#x3D; layer[::-1]: #回文数判定26 return False27 queue &#x3D; next_queue28 return True 递归法：思路：对每一层递归，首先两个节点必须存在，对于被检查的两个节点值必须相等。然后处理镜像：对于一对兄弟节点，左节点的右（左）子节点与右节点的左（右）子节点相等，递归检查 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isSymmetric(self, root: TreeNode) -&gt; bool:10 def check(node1,node2):11 if not node1 and not node2:12 return True13 elif not node1 or not node2:14 return False15 if node1.val !&#x3D; node2.val:16 return False17 return check(node1.left,node2.right) and check(node1.right,node2.left)1819 return check(root,root)","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-101/","photos":[]},{"tags":[],"title":"Hello World","date":"2019/12/06","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"http://ryhenkao.github.io/2019/12/06/hello-world/","photos":[]}]}