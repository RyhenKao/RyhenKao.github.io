{"meta":{"title":"Ryhen'blog |Code|Life|Love","subtitle":"","description":"","author":"Ryhen Kao","url":"http://ryhenkao.github.io","root":"/"},"posts":[{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"数据加密标准 DES","date":"2019/12/19","text":"概念对称加密：加密密钥=解密密钥 序列（流）密码：对明文数据进行逐位（每一比特或是每一字节）进行异或 分组密码： 将明文数据分成等长的若干组再进行处理 分组密码输出块中的每一位都是由（输入块+钥匙）的每一位决定的 方式：代替、置换、异或 产生效果： 1混淆：代替、异或2扩散：移位 特点：良好的扩散性和对插入的敏感性 代替与换位代替（S盒） 1混淆：不同输入导致相同的输出2扩散：输入数据中1bit的变换造成多个bit的输出变换3操作：算术&#x2F;逻辑运算，非线性映射4受计算机字长和计算能力的限制，代替处理的数据宽度有限。需要多个代替模块 换位（置换）permutation 1交换各个数据位的位置 代替+换位=更大规模的混淆与扩散效果 Feistel结构一次加密 1(密钥+临时数据)代替与换位&#x3D;密钥流2(明文+密钥流)异或&#x3D;密文 多次加密 1将上一次加密得到的密文作为下一轮的“明文”输入继续迭代加密 Feistel 1将明文分为左右段（L与R），每个一次加密时将L作为上述的明文，2R作为临时数据与密钥进行代替与换位构成密钥流。3密钥流与L进行异或，最后再将结果左右交换（L、R互换）进入下一轮。4最后一轮不进行左右交换。 扩展Feistel DES特点分组密码 ：明、密文分组长度64比特，密钥64比特（8比特做奇偶校验） 面向二进制数据 对合运算 综合运用了置换、代替、异或 属于典型的Feistel结构 应用世界范围内的广泛应用 被许多国际组织采用为标准 结论其设计目标是安全的 设计精巧、容易实现、使用方便 为国际信息安全发挥重要作用 DES算法 密钥扩展 16轮的Feistel结构 数学描述 算法框架1置换1：64bit筛选剩余56bit，平均分成左右两部分C，D2循环移位：C、D两段分别进行循环移位 3置换2：56bit筛选剩余48bit 置换选择1 1去掉每8位中的最后一位（奇偶校验位）2打乱重排（行列互换） 循环移位 1按照固定好的移位步数进行移位 置换选择2 1按照固定的矩阵从56bit选出48bit 16轮Feistel 8.1 初始置换IP 1按照固定矩阵进行初始置换2对加密没有贡献 8.2 逆初始置换IP-1 1与初始置换互逆 8.3 加密函数F 1扩展置换E：使用重复数据将把32位扩展成48位2S盒：每一个S盒有6个输入4个输出，非线性压缩；3S盒的输入s1s2s3s4s5s6中，s1s6表示行号，4s2s3s4s5表示列号，通过行列序号位置找到矩阵中5的对应值进行变换；DES中唯一的非线性变换；6共有8个S盒；7置换运算P:把数据打乱重排 解密运算 由于DES的对合特性：子密钥的使用顺序与加密时相反，从K16~K1依次使用，即可解密。 10 . 破译 弱密钥 互补对称性","permalink":"http://ryhenkao.github.io/2019/12/19/DES/","photos":[]},{"tags":[{"name":"密码学","slug":"密码学","permalink":"http://ryhenkao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"title":"应用密码学复习重点","date":"2019/12/19","text":"密码杂凑函数 密码杂凑函数的定义和安全性：抗原性攻击、抗第二原像攻击、抗碰撞 密码杂凑函数的比特安全性及原理 常用密码杂凑函数极其构造方式、杂凑值长度和安全性 密码杂凑函数的应用 分组密码 对加密通信的攻击：选择明文攻击、选择密文攻击 分组密码的定义 分组密码的两种典型构造：Feistel网络和S-P网络 常用分组密码极其构造方式、密钥长度和安全性 分组密码的模式（加密模式） 序列密码 One-Time Pad 序列密码的概念及其与分组密码的区别 MAC和AEAD 完整性（Integrity）及其对安全性的影响 MAC（消息认证码）算法的定义 AEAD的定义 常用的MAC算法和AEAD模式 密码分析 差分密码分析 线性密码分析 公钥密码 单向函数和单向陷门函数的定义和实例 群、环、域的定义和实例 公钥加密（Public Key Encryption）的定义 欧几里得算法和扩展欧几里得算法 Diffie-Hellman、ElGamal加密算法 椭圆曲线的定义和椭圆曲线算术：点加、倍点、点的标量乘法（PPoint Scalar Multiplication） 椭圆曲线困难问题ECDLP 椭圆曲线密钥长度和比特安全性的关系 素数和素性测试 素数、本原根（Primitive Roots）的定义 费马小定理、欧拉公式 素数生成算法 Miller-Rabin素性测试算法 RSA算法 RSA加密、RSA签名 为什么教科书中的RSA算法不安全 RSA的填充方案 数字证书与PKI 数字签名的概念与典型数字签名suanfa 数字证书、根证书、证书链、CA、PKI的概念，通过浏览器观察网站的证书链，了解现实中证书的各个域、DV/EV/OV证书的区别 基于身份的密码（Identity-Based Cryptography）的定义、典型构造、应用以及和传统公钥密码/PKI的区别 数学困难问题 离散对数问题、椭圆曲线离散对数问题、证书分解问题、DH问题、ECDH问题、RSA问题 平滑数的概念及其作用 大步小步法和Pohlig-Hellman算法 硬件安全 密码硬件安全等级1~4级的主要特征 侧信道攻击的种类 密文计算算法 同态加密、基于属性的加密（Attribute-Base Encryption）、可搜索加密、秘密共享/秘密分割、零知识证明、承诺、隐私信息获取（PIR）、不经意传输（OT）的基本概念和应用场景 典型同态加密算法支持的密文计算能力（明文类型和支持的计算类型、数量）","permalink":"http://ryhenkao.github.io/2019/12/19/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-122 买卖股票的最佳时机II","date":"2019/12/11","text":"思路：这道题看似跟上一题很类似（实际上也确实可以用上一题的解法），但是还有更简单的方法，对题目分析可以看出在同一天中是可以先将昨天买入的股票卖出然后再次买入的，这样的话我们就可以不用关心什么时候是最高点了（不用非得在最高价卖出）贪心法：只要今天的价格小于明天的价格，就在今天买入明天卖出（开了上帝视角的炒股神技？！） 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 if len(prices)&lt;&#x3D;1:4 return 05 max_profit&#x3D;06 for i in range(1,len(prices)):7 if prices[i]&gt;prices[i-1]:8 max_profit+&#x3D;prices[i]-prices[i-1]9 return max_profit","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-122/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-121 买卖股票的最佳时机","date":"2019/12/11","text":"双指针遍历:思路：在遍历数组的同时，维护两个指针，一个指针指向当前遍历过的最小值（股票的最低价），另一个指针指向当前可以得到的最大收益。通过维护两个指针我们可以仅在一次遍历数组的过程中得出答案 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 min_price &#x3D; float(&#39;inf&#39;)4 max_profit &#x3D; 05 for i in range(len(prices)):6 min_price &#x3D; min(prices[i], min_price)7 max_profit &#x3D; max(max_profit, prices[i]-min_price)8 return max_profit 动态规划法：思路：实际上，这是一个典型的动态规划问题，首先我们需要一个数组diff用来保存股票每天的变化情况，然后最重要的是找到动态规划的状态转移方程:dp[i]=max(0,dp[i-1]+diff[i])最后我们只需要从数组dp[]中找到最大值即可 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 if len(prices)&lt;&#x3D;1:4 return 05 diff &#x3D; [0 for _ in range(len(prices)-1)] #diff数组记录股票每两天之间差值6 for i in range(len(prices)-1):7 diff[i] &#x3D; prices[i+1]-prices[i]8 dp &#x3D; [0 for _ in range(len(prices)-1)] #dp数组用于动态规划9 dp[0] &#x3D; max(0,diff[0])10 max_profit &#x3D; dp[0]11 for i in range(1, len(prices)-1):12 dp[i] &#x3D; max(0, diff[i]+dp[i-1])13 max_profit &#x3D; max(max_profit, dp[i])14 return max_profit","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-121/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-119 杨辉三角II","date":"2019/12/11","text":"思路：与上一篇杨辉三角的解题思路相同，循环过程中需要记录上一层的数值，然后通过上一层的值求出当前层的数值；不同点在于这次我们只需要构造到题目要求的第K层，然后直接返回第K层的数组就行了 代码：1class Solution:2 def getRow(self, rowIndex: int) -&gt; List[int]:3 4 for i in range(rowIndex+1):5 now&#x3D;[1]*(i+1)6 if i&gt;&#x3D;1:7 for k in range(1,i):8 now[k]&#x3D;pre[k-1]+pre[k]9 pre&#x3D;now10 11 return now","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-119/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-118 杨辉三角","date":"2019/12/11","text":"思路：很明显我们首先需要使用一个for循环来构造numRows个数组来表示三角中的每一层。然后我们开始处理每一层中的元素，根据杨辉三角的构造方式，每一层的第一个以及最后一个元素的值等于1，其余的元素（假设脚标为i）的值就是上一行元素i（右上角）的值与上一行元素i-1（左上角）的值相加得出的 代码：1class Solution:2 def generate(self, numRows: int) -&gt; List[List[int]]:3 4 res&#x3D;[]5 if numRows&#x3D;&#x3D;0:6 return res7 for i in range(0,numRows):8 now&#x3D;[1]*(i+1)9 if i&gt;&#x3D;2:10 for k in range(1,i):11 now[k]&#x3D;pre[k-1]+pre[k]12 res.append(now)13 pre&#x3D;now14 return res","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-118/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-112 路径总和","date":"2019/12/11","text":"思路：在二叉树中搜索符合条件的路径，首先的思路就是通过DFS（深度优先搜索）对二叉树进行遍历，只要找到了符合条件的路径，返回结果True，否则返回False题目中我们需要考虑的两个约束条件：1.节点值的总和等于sum；2.路径必须是从根节点到叶子节点 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:10 if not root:11 return False12 if root.val&#x3D;&#x3D;sum: #判断节点值与sum的关系13 if not root.left and not root.right: #该节点是否为叶子节点14 return True15 sum &#x3D; sum - root.val16 left &#x3D; self.hasPathSum(root.left,sum) #递归搜索左右子树17 right &#x3D; self.hasPathSum(root.right,sum)18 return left or right","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-112/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-111 二叉树的最小深度","date":"2019/12/11","text":"思路：和之前做过的求二叉树深度的题目一样，只不过这次返回的是根节点到叶子节点之间最小的距离，同样使用DFS的思想找到叶子节点，并且同时计算距离即可。 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def minDepth(self, root: TreeNode) -&gt; int:10 if root:11 if root.left and root.right:12 return 1+min(self.minDepth(root.left),self.minDepth(root.right))13#节点存在左右子树的时候，返回较小的深度值14 elif root.left:15 return 1+self.minDepth(root.left) #节点只有一棵子树时，该子树的最小深度就是二叉树的最小深度16 elif root.right:17 return 1+self.minDepth(root.right)18 else:19 return 120 else:21 return 0","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-111/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-110 平衡二叉树","date":"2019/12/11","text":"思路：根据平衡二叉树的定义：每一个节点的左右两个子树高度差的绝对值不超过1，我们可以首先想到的是需要一个计算二叉树高度的函数，这应该是一个我们非常熟悉的函数，通过DFS的方式计算二叉树高度。由于“每一个节点”都满足定义，于是我们可以很快想到采用——递归，对每一个节点都采用相同的方法进行判断，判断是否每个节点的左右子树高度差绝对值小于等于1 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isBalanced(self, root: TreeNode) -&gt; bool:10 def height(root:TreeNode,depth):11 if root&#x3D;&#x3D;None:12 return depth13 elif root.right&#x3D;&#x3D;None and root.left&#x3D;&#x3D;None:14 return depth+115 else:16 left&#x3D;height(root.left,depth+1)17 right&#x3D;height(root.right,depth+1)18 depth &#x3D; max(left,right)19 return depth2021 if root&#x3D;&#x3D;None:22 return True23 left &#x3D; self.isBalanced(root.left)24 right &#x3D; self.isBalanced(root.right)25 if left and right:26 flag&#x3D; abs(height(root.left,0)-height(root.right,0))&lt;&#x3D;127 return flag28 return False","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-110/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-108 有序数组转化为二叉搜索树","date":"2019/12/11","text":"思路：首先对于二叉搜索树：所有的节点满足该节点的左子节点值小于该节点值，该节点的右子节点值大于该节点值。并且根据二叉搜索树的特点：中序遍历一棵二叉搜索树所得序列是一个升序的有序数组。从这个特点反推，这棵二叉搜索树的根节点就应该是有序数组的中间点，每棵子树的根节点也都是被分割（除去中间节点的左右两个子数组）以后的子数组的中间点。综上我们得出了构造二叉搜索树的递归算法 代码：1# class TreeNode:2# def __init__(self, x):3# self.val &#x3D; x4# self.left &#x3D; None5# self.right &#x3D; None67class Solution:8 def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:9 if not nums:10 return None11 else:12 mid &#x3D; len(nums)&#x2F;&#x2F;213 Tree&#x3D;TreeNode(nums[mid])14 nums_left&#x3D;nums[0:mid]15 nums_right&#x3D;nums[mid+1:len(nums)]16 Tree.left&#x3D;self.sortedArrayToBST(nums_left)17 Tree.right&#x3D;self.sortedArrayToBST(nums_right)1819 return Tree","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-108/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-104 二叉树的最大深度","date":"2019/12/11","text":"思路：设定一个计数值depth记录当前深度，采用深度优先遍历，最后比较左右子树深度，返回深度较大的depth值 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def getDepth(self, root, depth):10 if not root:11 return depth #节点为空则返回当前深度12 elif not root.left and not root.right:13 return depth+1 #节点不为空且有子节点，则深度值+114 l&#x3D;self.getDepth(root.left,depth+1) #深度优先遍历左子树15 r&#x3D;self.getDepth(root.right,depth+1) #深度优先遍历右子树1617 return max(l,r) #返回较大的深度值181920 def maxDepth(self, root: TreeNode) -&gt; int:21 if not root:22 return 023 depth&#x3D;024 depth&#x3D;self.getDepth(root,depth)25 return depth","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-104/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-101 对称二叉树","date":"2019/12/11","text":"迭代法：思路：层次遍历的每一层的节点，每层存入一个数组中，若二叉树对称，每层都是一个回文数 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isSymmetric(self, root: TreeNode) -&gt; bool:10 if not root:11 return True12 queue&#x3D;[root]13 while(queue):14 next_queue&#x3D;list() #存储下一层的节点（从左至右）15 layer&#x3D;list() #存储当前层的节点值16 for node in queue:17 if not node:18 layer.append(None)19 continue20 next_queue.append(node.left)21 next_queue.append(node.right)2223 layer.append(node.val)2425 if layer !&#x3D; layer[::-1]: #回文数判定26 return False27 queue &#x3D; next_queue28 return True 递归法：思路：对每一层递归，首先两个节点必须存在，对于被检查的两个节点值必须相等。然后处理镜像：对于一对兄弟节点，左节点的右（左）子节点与右节点的左（右）子节点相等，递归检查 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isSymmetric(self, root: TreeNode) -&gt; bool:10 def check(node1,node2):11 if not node1 and not node2:12 return True13 elif not node1 or not node2:14 return False15 if node1.val !&#x3D; node2.val:16 return False17 return check(node1.left,node2.right) and check(node1.right,node2.left)1819 return check(root,root)","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-101/","photos":[]},{"tags":[],"title":"Hello World","date":"2019/12/06","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"http://ryhenkao.github.io/2019/12/06/hello-world/","photos":[]}]}