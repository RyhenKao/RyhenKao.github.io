{"meta":{"title":"Ryhen'blog |Code|Life|Love","subtitle":"","description":"","author":"Ryhen Kao","url":"http://ryhenkao.github.io","root":"/"},"posts":[{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-122 买卖股票的最佳时机II","date":"2019/12/11","text":"思路：这道题看似跟上一题很类似（实际上也确实可以用上一题的解法），但是还有更简单的方法，对题目分析可以看出在同一天中是可以先将昨天买入的股票卖出然后再次买入的，这样的话我们就可以不用关心什么时候是最高点了（不用非得在最高价卖出）贪心法：只要今天的价格小于明天的价格，就在今天买入明天卖出（开了上帝视角的炒股神技？！） 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 if len(prices)&lt;&#x3D;1:4 return 05 max_profit&#x3D;06 for i in range(1,len(prices)):7 if prices[i]&gt;prices[i-1]:8 max_profit+&#x3D;prices[i]-prices[i-1]9 return max_profit","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-122/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-121 买卖股票的最佳时机","date":"2019/12/11","text":"双指针遍历:思路：在遍历数组的同时，维护两个指针，一个指针指向当前遍历过的最小值（股票的最低价），另一个指针指向当前可以得到的最大收益。通过维护两个指针我们可以仅在一次遍历数组的过程中得出答案 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 min_price &#x3D; float(&#39;inf&#39;)4 max_profit &#x3D; 05 for i in range(len(prices)):6 min_price &#x3D; min(prices[i], min_price)7 max_profit &#x3D; max(max_profit, prices[i]-min_price)8 return max_profit 动态规划法：思路：实际上，这是一个典型的动态规划问题，首先我们需要一个数组diff用来保存股票每天的变化情况，然后最重要的是找到动态规划的状态转移方程:dp[i]=max(0,dp[i-1]+diff[i])最后我们只需要从数组dp[]中找到最大值即可 代码：1class Solution:2 def maxProfit(self, prices: List[int]) -&gt; int:3 if len(prices)&lt;&#x3D;1:4 return 05 diff &#x3D; [0 for _ in range(len(prices)-1)] #diff数组记录股票每两天之间差值6 for i in range(len(prices)-1):7 diff[i] &#x3D; prices[i+1]-prices[i]8 dp &#x3D; [0 for _ in range(len(prices)-1)] #dp数组用于动态规划9 dp[0] &#x3D; max(0,diff[0])10 max_profit &#x3D; dp[0]11 for i in range(1, len(prices)-1):12 dp[i] &#x3D; max(0, diff[i]+dp[i-1])13 max_profit &#x3D; max(max_profit, dp[i])14 return max_profit","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-121/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-119 杨辉三角II","date":"2019/12/11","text":"思路：与上一篇杨辉三角的解题思路相同，循环过程中需要记录上一层的数值，然后通过上一层的值求出当前层的数值；不同点在于这次我们只需要构造到题目要求的第K层，然后直接返回第K层的数组就行了 代码：1class Solution:2 def getRow(self, rowIndex: int) -&gt; List[int]:3 4 for i in range(rowIndex+1):5 now&#x3D;[1]*(i+1)6 if i&gt;&#x3D;1:7 for k in range(1,i):8 now[k]&#x3D;pre[k-1]+pre[k]9 pre&#x3D;now10 11 return now","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-119/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-118 杨辉三角","date":"2019/12/11","text":"思路：很明显我们首先需要使用一个for循环来构造numRows个数组来表示三角中的每一层。然后我们开始处理每一层中的元素，根据杨辉三角的构造方式，每一层的第一个以及最后一个元素的值等于1，其余的元素（假设脚标为i）的值就是上一行元素i（右上角）的值与上一行元素i-1（左上角）的值相加得出的 代码：1class Solution:2 def generate(self, numRows: int) -&gt; List[List[int]]:3 4 res&#x3D;[]5 if numRows&#x3D;&#x3D;0:6 return res7 for i in range(0,numRows):8 now&#x3D;[1]*(i+1)9 if i&gt;&#x3D;2:10 for k in range(1,i):11 now[k]&#x3D;pre[k-1]+pre[k]12 res.append(now)13 pre&#x3D;now14 return res","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-118/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-112 路径总和","date":"2019/12/11","text":"思路：在二叉树中搜索符合条件的路径，首先的思路就是通过DFS（深度优先搜索）对二叉树进行遍历，只要找到了符合条件的路径，返回结果True，否则返回False题目中我们需要考虑的两个约束条件：1.节点值的总和等于sum；2.路径必须是从根节点到叶子节点 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:10 if not root:11 return False12 if root.val&#x3D;&#x3D;sum: #判断节点值与sum的关系13 if not root.left and not root.right: #该节点是否为叶子节点14 return True15 sum &#x3D; sum - root.val16 left &#x3D; self.hasPathSum(root.left,sum) #递归搜索左右子树17 right &#x3D; self.hasPathSum(root.right,sum)18 return left or right","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-112/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-111 二叉树的最小深度","date":"2019/12/11","text":"思路：和之前做过的求二叉树深度的题目一样，只不过这次返回的是根节点到叶子节点之间最小的距离，同样使用DFS的思想找到叶子节点，并且同时计算距离即可。 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def minDepth(self, root: TreeNode) -&gt; int:10 if root:11 if root.left and root.right:12 return 1+min(self.minDepth(root.left),self.minDepth(root.right))13#节点存在左右子树的时候，返回较小的深度值14 elif root.left:15 return 1+self.minDepth(root.left) #节点只有一棵子树时，该子树的最小深度就是二叉树的最小深度16 elif root.right:17 return 1+self.minDepth(root.right)18 else:19 return 120 else:21 return 0","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-111/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-110 平衡二叉树","date":"2019/12/11","text":"思路：根据平衡二叉树的定义：每一个节点的左右两个子树高度差的绝对值不超过1，我们可以首先想到的是需要一个计算二叉树高度的函数，这应该是一个我们非常熟悉的函数，通过DFS的方式计算二叉树高度。由于“每一个节点”都满足定义，于是我们可以很快想到采用——递归，对每一个节点都采用相同的方法进行判断，判断是否每个节点的左右子树高度差绝对值小于等于1 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isBalanced(self, root: TreeNode) -&gt; bool:10 def height(root:TreeNode,depth):11 if root&#x3D;&#x3D;None:12 return depth13 elif root.right&#x3D;&#x3D;None and root.left&#x3D;&#x3D;None:14 return depth+115 else:16 left&#x3D;height(root.left,depth+1)17 right&#x3D;height(root.right,depth+1)18 depth &#x3D; max(left,right)19 return depth2021 if root&#x3D;&#x3D;None:22 return True23 left &#x3D; self.isBalanced(root.left)24 right &#x3D; self.isBalanced(root.right)25 if left and right:26 flag&#x3D; abs(height(root.left,0)-height(root.right,0))&lt;&#x3D;127 return flag28 return False","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-110/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-108 有序数组转化为二叉搜索树","date":"2019/12/11","text":"思路：首先对于二叉搜索树：所有的节点满足该节点的左子节点值小于该节点值，该节点的右子节点值大于该节点值。并且根据二叉搜索树的特点：中序遍历一棵二叉搜索树所得序列是一个升序的有序数组。从这个特点反推，这棵二叉搜索树的根节点就应该是有序数组的中间点，每棵子树的根节点也都是被分割（除去中间节点的左右两个子数组）以后的子数组的中间点。综上我们得出了构造二叉搜索树的递归算法 代码：1# class TreeNode:2# def __init__(self, x):3# self.val &#x3D; x4# self.left &#x3D; None5# self.right &#x3D; None67class Solution:8 def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:9 if not nums:10 return None11 else:12 mid &#x3D; len(nums)&#x2F;&#x2F;213 Tree&#x3D;TreeNode(nums[mid])14 nums_left&#x3D;nums[0:mid]15 nums_right&#x3D;nums[mid+1:len(nums)]16 Tree.left&#x3D;self.sortedArrayToBST(nums_left)17 Tree.right&#x3D;self.sortedArrayToBST(nums_right)1819 return Tree","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-108/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-104 二叉树的最大深度","date":"2019/12/11","text":"思路：设定一个计数值depth记录当前深度，采用深度优先遍历，最后比较左右子树深度，返回深度较大的depth值 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def getDepth(self, root, depth):10 if not root:11 return depth #节点为空则返回当前深度12 elif not root.left and not root.right:13 return depth+1 #节点不为空且有子节点，则深度值+114 l&#x3D;self.getDepth(root.left,depth+1) #深度优先遍历左子树15 r&#x3D;self.getDepth(root.right,depth+1) #深度优先遍历右子树1617 return max(l,r) #返回较大的深度值181920 def maxDepth(self, root: TreeNode) -&gt; int:21 if not root:22 return 023 depth&#x3D;024 depth&#x3D;self.getDepth(root,depth)25 return depth","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-104/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ryhenkao.github.io/tags/LeetCode/"}],"title":"LeetCode-101 对称二叉树","date":"2019/12/11","text":"迭代法：思路：层次遍历的每一层的节点，每层存入一个数组中，若二叉树对称，每层都是一个回文数 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isSymmetric(self, root: TreeNode) -&gt; bool:10 if not root:11 return True12 queue&#x3D;[root]13 while(queue):14 next_queue&#x3D;list() #存储下一层的节点（从左至右）15 layer&#x3D;list() #存储当前层的节点值16 for node in queue:17 if not node:18 layer.append(None)19 continue20 next_queue.append(node.left)21 next_queue.append(node.right)2223 layer.append(node.val)2425 if layer !&#x3D; layer[::-1]: #回文数判定26 return False27 queue &#x3D; next_queue28 return True 递归法：思路：对每一层递归，首先两个节点必须存在，对于被检查的两个节点值必须相等。然后处理镜像：对于一对兄弟节点，左节点的右（左）子节点与右节点的左（右）子节点相等，递归检查 代码：1# Definition for a binary tree node.2# class TreeNode:3# def __init__(self, x):4# self.val &#x3D; x5# self.left &#x3D; None6# self.right &#x3D; None78class Solution:9 def isSymmetric(self, root: TreeNode) -&gt; bool:10 def check(node1,node2):11 if not node1 and not node2:12 return True13 elif not node1 or not node2:14 return False15 if node1.val !&#x3D; node2.val:16 return False17 return check(node1.left,node2.right) and check(node1.right,node2.left)1819 return check(root,root)","permalink":"http://ryhenkao.github.io/2019/12/11/LeetCode-101/","photos":[]},{"tags":[],"title":"Hello World","date":"2019/12/06","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"http://ryhenkao.github.io/2019/12/06/hello-world/","photos":[]}]}